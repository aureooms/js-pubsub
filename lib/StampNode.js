"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

/**
 * pubsub node that only notifies clients whose stamp is less than
 * the currently published stamp.
 *
 * @param {dict} subscriptions a ( key, stamp ) python-style dict
 * @param {comparable} stamp
 * @param {comparator} compare the comparison function used to compare stamps
 */
var StampNode = exports.StampNode = function StampNode(subscriptions, stamp, compare) {
	this.subscriptions = subscriptions;
	this.stamp = stamp;
	this.compare = compare;
};

/**
 * Subscribes client with key *key* and stamp *stamp*. If
 * *stamp* < current stamp then we forward the current stamp
 * to client with key *key*.
 *
 * @param  {key} key      key of the subscriber
 * @param  {comparable} stamp   most up to date stamp the subscriber has
 * @param  {callback} forward the function to call when the stamp for a client
 *                    is outdated
 */

StampNode.prototype.subscribe = function (key, stamp, forward) {

	this.subscriptions.set(key, this.update(forward)(key, stamp));
};

StampNode.prototype.unsubscribe = function (key) {

	this.subscriptions.unset(key);
};

StampNode.prototype.publish = function (stamp, forward) {

	this.stamp = stamp;

	this.subscriptions.update(this.update(forward));
};

StampNode.prototype.update = function (forward) {

	var that = this;

	return function (key, stamp) {

		if (that.compare(that.stamp, stamp) > 0) {

			forward(key, that.stamp);

			return that.stamp;
		} else {

			return stamp;
		}
	};
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9TdGFtcE5vZGUuanMiXSwibmFtZXMiOlsiU3RhbXBOb2RlIiwic3Vic2NyaXB0aW9ucyIsInN0YW1wIiwiY29tcGFyZSIsInByb3RvdHlwZSIsInN1YnNjcmliZSIsImtleSIsImZvcndhcmQiLCJzZXQiLCJ1cGRhdGUiLCJ1bnN1YnNjcmliZSIsInVuc2V0IiwicHVibGlzaCIsInRoYXQiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUNBOzs7Ozs7OztBQVFPLElBQU1BLGdDQUFZLFNBQVpBLFNBQVksQ0FBV0MsYUFBWCxFQUEwQkMsS0FBMUIsRUFBaUNDLE9BQWpDLEVBQTJDO0FBQ25FLE1BQUtGLGFBQUwsR0FBcUJBLGFBQXJCO0FBQ0EsTUFBS0MsS0FBTCxHQUFhQSxLQUFiO0FBQ0EsTUFBS0MsT0FBTCxHQUFlQSxPQUFmO0FBQ0EsQ0FKTTs7QUFPUDs7Ozs7Ozs7Ozs7QUFXQUgsVUFBVUksU0FBVixDQUFvQkMsU0FBcEIsR0FBZ0MsVUFBV0MsR0FBWCxFQUFnQkosS0FBaEIsRUFBdUJLLE9BQXZCLEVBQWlDOztBQUVoRSxNQUFLTixhQUFMLENBQW1CTyxHQUFuQixDQUF3QkYsR0FBeEIsRUFBNkIsS0FBS0csTUFBTCxDQUFhRixPQUFiLEVBQXdCRCxHQUF4QixFQUE2QkosS0FBN0IsQ0FBN0I7QUFFQSxDQUpEOztBQU9BRixVQUFVSSxTQUFWLENBQW9CTSxXQUFwQixHQUFrQyxVQUFXSixHQUFYLEVBQWlCOztBQUVsRCxNQUFLTCxhQUFMLENBQW1CVSxLQUFuQixDQUEwQkwsR0FBMUI7QUFFQSxDQUpEOztBQU9BTixVQUFVSSxTQUFWLENBQW9CUSxPQUFwQixHQUE4QixVQUFXVixLQUFYLEVBQWtCSyxPQUFsQixFQUE0Qjs7QUFFekQsTUFBS0wsS0FBTCxHQUFhQSxLQUFiOztBQUVBLE1BQUtELGFBQUwsQ0FBbUJRLE1BQW5CLENBQTJCLEtBQUtBLE1BQUwsQ0FBYUYsT0FBYixDQUEzQjtBQUVBLENBTkQ7O0FBUUFQLFVBQVVJLFNBQVYsQ0FBb0JLLE1BQXBCLEdBQTZCLFVBQVdGLE9BQVgsRUFBcUI7O0FBRWpELEtBQU1NLE9BQU8sSUFBYjs7QUFFQSxRQUFPLFVBQVdQLEdBQVgsRUFBZ0JKLEtBQWhCLEVBQXdCOztBQUU5QixNQUFLVyxLQUFLVixPQUFMLENBQWNVLEtBQUtYLEtBQW5CLEVBQTBCQSxLQUExQixJQUFvQyxDQUF6QyxFQUE2Qzs7QUFFNUNLLFdBQVNELEdBQVQsRUFBY08sS0FBS1gsS0FBbkI7O0FBRUEsVUFBT1csS0FBS1gsS0FBWjtBQUNBLEdBTEQsTUFPSzs7QUFFSixVQUFPQSxLQUFQO0FBRUE7QUFFRCxFQWZEO0FBaUJBLENBckJEIiwiZmlsZSI6IlN0YW1wTm9kZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBwdWJzdWIgbm9kZSB0aGF0IG9ubHkgbm90aWZpZXMgY2xpZW50cyB3aG9zZSBzdGFtcCBpcyBsZXNzIHRoYW5cbiAqIHRoZSBjdXJyZW50bHkgcHVibGlzaGVkIHN0YW1wLlxuICpcbiAqIEBwYXJhbSB7ZGljdH0gc3Vic2NyaXB0aW9ucyBhICgga2V5LCBzdGFtcCApIHB5dGhvbi1zdHlsZSBkaWN0XG4gKiBAcGFyYW0ge2NvbXBhcmFibGV9IHN0YW1wXG4gKiBAcGFyYW0ge2NvbXBhcmF0b3J9IGNvbXBhcmUgdGhlIGNvbXBhcmlzb24gZnVuY3Rpb24gdXNlZCB0byBjb21wYXJlIHN0YW1wc1xuICovXG5leHBvcnQgY29uc3QgU3RhbXBOb2RlID0gZnVuY3Rpb24gKCBzdWJzY3JpcHRpb25zLCBzdGFtcCwgY29tcGFyZSApIHtcblx0dGhpcy5zdWJzY3JpcHRpb25zID0gc3Vic2NyaXB0aW9ucztcblx0dGhpcy5zdGFtcCA9IHN0YW1wO1xuXHR0aGlzLmNvbXBhcmUgPSBjb21wYXJlO1xufSA7XG5cblxuLyoqXG4gKiBTdWJzY3JpYmVzIGNsaWVudCB3aXRoIGtleSAqa2V5KiBhbmQgc3RhbXAgKnN0YW1wKi4gSWZcbiAqICpzdGFtcCogPCBjdXJyZW50IHN0YW1wIHRoZW4gd2UgZm9yd2FyZCB0aGUgY3VycmVudCBzdGFtcFxuICogdG8gY2xpZW50IHdpdGgga2V5ICprZXkqLlxuICpcbiAqIEBwYXJhbSAge2tleX0ga2V5ICAgICAga2V5IG9mIHRoZSBzdWJzY3JpYmVyXG4gKiBAcGFyYW0gIHtjb21wYXJhYmxlfSBzdGFtcCAgIG1vc3QgdXAgdG8gZGF0ZSBzdGFtcCB0aGUgc3Vic2NyaWJlciBoYXNcbiAqIEBwYXJhbSAge2NhbGxiYWNrfSBmb3J3YXJkIHRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIHN0YW1wIGZvciBhIGNsaWVudFxuICogICAgICAgICAgICAgICAgICAgIGlzIG91dGRhdGVkXG4gKi9cblxuU3RhbXBOb2RlLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoIGtleSwgc3RhbXAsIGZvcndhcmQgKSB7XG5cblx0dGhpcy5zdWJzY3JpcHRpb25zLnNldCgga2V5LCB0aGlzLnVwZGF0ZSggZm9yd2FyZCApKCBrZXksIHN0YW1wICkgKTtcblxufTtcblxuXG5TdGFtcE5vZGUucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCBrZXkgKSB7XG5cblx0dGhpcy5zdWJzY3JpcHRpb25zLnVuc2V0KCBrZXkgKTtcblxufTtcblxuXG5TdGFtcE5vZGUucHJvdG90eXBlLnB1Ymxpc2ggPSBmdW5jdGlvbiAoIHN0YW1wLCBmb3J3YXJkICkge1xuXG5cdHRoaXMuc3RhbXAgPSBzdGFtcDtcblxuXHR0aGlzLnN1YnNjcmlwdGlvbnMudXBkYXRlKCB0aGlzLnVwZGF0ZSggZm9yd2FyZCApICk7XG5cbn07XG5cblN0YW1wTm9kZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCBmb3J3YXJkICkge1xuXG5cdGNvbnN0IHRoYXQgPSB0aGlzO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoIGtleSwgc3RhbXAgKSB7XG5cblx0XHRpZiAoIHRoYXQuY29tcGFyZSggdGhhdC5zdGFtcCwgc3RhbXAgKSA+IDAgKSB7XG5cblx0XHRcdGZvcndhcmQoIGtleSwgdGhhdC5zdGFtcCApO1xuXG5cdFx0XHRyZXR1cm4gdGhhdC5zdGFtcDtcblx0XHR9XG5cblx0XHRlbHNlIHtcblxuXHRcdFx0cmV0dXJuIHN0YW1wO1xuXG5cdFx0fVxuXG5cdH07XG5cbn07XG4iXX0=