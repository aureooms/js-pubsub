"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

/**
 * pubsub node that only notifies clients whose stamp is less than
 * the currently published stamp.
 *
 * @param {dict} subscriptions a ( key, stamp ) python-style dict
 * @param {comparable} stamp
 * @param {comparator} the comparison function used to compare stamps
 */
var StampNode = exports.StampNode = function StampNode(subscriptions, stamp, compare) {
	this.subscriptions = subscriptions;
	this.stamp = stamp;
	this.compare = compare;
};

/**
 * Subscribes client with key *key* and stamp *stamp*. If
 * *stamp* < current stamp then we forward the current stamp
 * to client with key *key*.
 *
 * @param  {key} key      key of the subscriber
 * @param  {comparable} stamp   most up to date stamp the subscriber has
 * @param  {callback} forward the function to call when the stamp for a client
 *                    is outdated
 */

StampNode.prototype.subscribe = function (key, stamp, forward) {

	this.subscriptions.set(key, this.update(forward)(key, stamp));
};

StampNode.prototype.unsubscribe = function (key) {

	this.subscriptions.unset(key);
};

StampNode.prototype.publish = function (stamp, forward) {

	this.stamp = stamp;

	this.subscriptions.update(this.update(forward));
};

StampNode.prototype.update = function (forward) {

	var that = this;

	return function (key, stamp) {

		if (that.compare(that.stamp, stamp) > 0) {

			forward(key, that.stamp);

			return that.stamp;
		} else {

			return stamp;
		}
	};
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9TdGFtcE5vZGUuanMiXSwibmFtZXMiOlsiU3RhbXBOb2RlIiwic3Vic2NyaXB0aW9ucyIsInN0YW1wIiwiY29tcGFyZSIsInByb3RvdHlwZSIsInN1YnNjcmliZSIsImtleSIsImZvcndhcmQiLCJzZXQiLCJ1cGRhdGUiLCJ1bnN1YnNjcmliZSIsInVuc2V0IiwicHVibGlzaCIsInRoYXQiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUNBOzs7Ozs7OztBQVFPLElBQU1BLGdDQUFZLFNBQVpBLFNBQVksQ0FBV0MsYUFBWCxFQUEwQkMsS0FBMUIsRUFBaUNDLE9BQWpDLEVBQTJDO0FBQ25FLE1BQUtGLGFBQUwsR0FBcUJBLGFBQXJCO0FBQ0EsTUFBS0MsS0FBTCxHQUFhQSxLQUFiO0FBQ0EsTUFBS0MsT0FBTCxHQUFlQSxPQUFmO0FBQ0EsQ0FKTTs7QUFPUDs7Ozs7Ozs7Ozs7QUFXQUgsVUFBVUksU0FBVixDQUFvQkMsU0FBcEIsR0FBZ0MsVUFBV0MsR0FBWCxFQUFnQkosS0FBaEIsRUFBdUJLLE9BQXZCLEVBQWlDOztBQUVoRSxNQUFLTixhQUFMLENBQW1CTyxHQUFuQixDQUF3QkYsR0FBeEIsRUFBNkIsS0FBS0csTUFBTCxDQUFhRixPQUFiLEVBQXdCRCxHQUF4QixFQUE2QkosS0FBN0IsQ0FBN0I7QUFFQSxDQUpEOztBQU9BRixVQUFVSSxTQUFWLENBQW9CTSxXQUFwQixHQUFrQyxVQUFXSixHQUFYLEVBQWlCOztBQUVsRCxNQUFLTCxhQUFMLENBQW1CVSxLQUFuQixDQUEwQkwsR0FBMUI7QUFFQSxDQUpEOztBQU9BTixVQUFVSSxTQUFWLENBQW9CUSxPQUFwQixHQUE4QixVQUFXVixLQUFYLEVBQWtCSyxPQUFsQixFQUE0Qjs7QUFFekQsTUFBS0wsS0FBTCxHQUFhQSxLQUFiOztBQUVBLE1BQUtELGFBQUwsQ0FBbUJRLE1BQW5CLENBQTJCLEtBQUtBLE1BQUwsQ0FBYUYsT0FBYixDQUEzQjtBQUVBLENBTkQ7O0FBUUFQLFVBQVVJLFNBQVYsQ0FBb0JLLE1BQXBCLEdBQTZCLFVBQVdGLE9BQVgsRUFBcUI7O0FBRWpELEtBQU1NLE9BQU8sSUFBYjs7QUFFQSxRQUFPLFVBQVdQLEdBQVgsRUFBZ0JKLEtBQWhCLEVBQXdCOztBQUU5QixNQUFLVyxLQUFLVixPQUFMLENBQWNVLEtBQUtYLEtBQW5CLEVBQTBCQSxLQUExQixJQUFvQyxDQUF6QyxFQUE2Qzs7QUFFNUNLLFdBQVNELEdBQVQsRUFBY08sS0FBS1gsS0FBbkI7O0FBRUEsVUFBT1csS0FBS1gsS0FBWjtBQUNBLEdBTEQsTUFPSzs7QUFFSixVQUFPQSxLQUFQO0FBRUE7QUFFRCxFQWZEO0FBaUJBLENBckJEIiwiZmlsZSI6IlN0YW1wTm9kZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBwdWJzdWIgbm9kZSB0aGF0IG9ubHkgbm90aWZpZXMgY2xpZW50cyB3aG9zZSBzdGFtcCBpcyBsZXNzIHRoYW5cbiAqIHRoZSBjdXJyZW50bHkgcHVibGlzaGVkIHN0YW1wLlxuICpcbiAqIEBwYXJhbSB7ZGljdH0gc3Vic2NyaXB0aW9ucyBhICgga2V5LCBzdGFtcCApIHB5dGhvbi1zdHlsZSBkaWN0XG4gKiBAcGFyYW0ge2NvbXBhcmFibGV9IHN0YW1wXG4gKiBAcGFyYW0ge2NvbXBhcmF0b3J9IHRoZSBjb21wYXJpc29uIGZ1bmN0aW9uIHVzZWQgdG8gY29tcGFyZSBzdGFtcHNcbiAqL1xuZXhwb3J0IGNvbnN0IFN0YW1wTm9kZSA9IGZ1bmN0aW9uICggc3Vic2NyaXB0aW9ucywgc3RhbXAsIGNvbXBhcmUgKSB7XG5cdHRoaXMuc3Vic2NyaXB0aW9ucyA9IHN1YnNjcmlwdGlvbnM7XG5cdHRoaXMuc3RhbXAgPSBzdGFtcDtcblx0dGhpcy5jb21wYXJlID0gY29tcGFyZTtcbn0gO1xuXG5cbi8qKlxuICogU3Vic2NyaWJlcyBjbGllbnQgd2l0aCBrZXkgKmtleSogYW5kIHN0YW1wICpzdGFtcCouIElmXG4gKiAqc3RhbXAqIDwgY3VycmVudCBzdGFtcCB0aGVuIHdlIGZvcndhcmQgdGhlIGN1cnJlbnQgc3RhbXBcbiAqIHRvIGNsaWVudCB3aXRoIGtleSAqa2V5Ki5cbiAqXG4gKiBAcGFyYW0gIHtrZXl9IGtleSAgICAgIGtleSBvZiB0aGUgc3Vic2NyaWJlclxuICogQHBhcmFtICB7Y29tcGFyYWJsZX0gc3RhbXAgICBtb3N0IHVwIHRvIGRhdGUgc3RhbXAgdGhlIHN1YnNjcmliZXIgaGFzXG4gKiBAcGFyYW0gIHtjYWxsYmFja30gZm9yd2FyZCB0aGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBzdGFtcCBmb3IgYSBjbGllbnRcbiAqICAgICAgICAgICAgICAgICAgICBpcyBvdXRkYXRlZFxuICovXG5cblN0YW1wTm9kZS5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCBrZXksIHN0YW1wLCBmb3J3YXJkICkge1xuXG5cdHRoaXMuc3Vic2NyaXB0aW9ucy5zZXQoIGtleSwgdGhpcy51cGRhdGUoIGZvcndhcmQgKSgga2V5LCBzdGFtcCApICk7XG5cbn07XG5cblxuU3RhbXBOb2RlLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgga2V5ICkge1xuXG5cdHRoaXMuc3Vic2NyaXB0aW9ucy51bnNldCgga2V5ICk7XG5cbn07XG5cblxuU3RhbXBOb2RlLnByb3RvdHlwZS5wdWJsaXNoID0gZnVuY3Rpb24gKCBzdGFtcCwgZm9yd2FyZCApIHtcblxuXHR0aGlzLnN0YW1wID0gc3RhbXA7XG5cblx0dGhpcy5zdWJzY3JpcHRpb25zLnVwZGF0ZSggdGhpcy51cGRhdGUoIGZvcndhcmQgKSApO1xuXG59O1xuXG5TdGFtcE5vZGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICggZm9yd2FyZCApIHtcblxuXHRjb25zdCB0aGF0ID0gdGhpcztcblxuXHRyZXR1cm4gZnVuY3Rpb24gKCBrZXksIHN0YW1wICkge1xuXG5cdFx0aWYgKCB0aGF0LmNvbXBhcmUoIHRoYXQuc3RhbXAsIHN0YW1wICkgPiAwICkge1xuXG5cdFx0XHRmb3J3YXJkKCBrZXksIHRoYXQuc3RhbXAgKTtcblxuXHRcdFx0cmV0dXJuIHRoYXQuc3RhbXA7XG5cdFx0fVxuXG5cdFx0ZWxzZSB7XG5cblx0XHRcdHJldHVybiBzdGFtcDtcblxuXHRcdH1cblxuXHR9O1xuXG59O1xuIl19